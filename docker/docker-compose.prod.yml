version: '3.8'

# Production-optimized Docker Compose configuration
# Features: security hardening, resource limits, monitoring, high availability
# CONFIGURATION: Uses .env file for environment variables
# MONITORING: Integrated observability stack
# BACKUP: Automated database backups

# Configuration for production

services:
  # Environment validation container
  env-validator:
    image: alpine:latest
    container_name: tinyboards_env_validator
    command: |
      sh -c '
      if [ -z "$$POSTGRES_PASSWORD" ]; then echo "POSTGRES_PASSWORD not set"; exit 1; fi
      if [ -z "$$JWT_SECRET" ]; then echo "JWT_SECRET not set"; exit 1; fi
      if [ -z "$$REDIS_PASSWORD" ]; then echo "REDIS_PASSWORD not set"; exit 1; fi
      if [ -z "$$DOMAIN" ]; then echo "DOMAIN not set"; exit 1; fi
      echo "Environment validation passed"
      '
    environment:
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - JWT_SECRET=${JWT_SECRET}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - DOMAIN=${DOMAIN}
    restart: "no"

  # Init container to fix volume permissions
  volume-permissions:
    image: alpine:latest
    container_name: tinyboards_volume_permissions
    volumes:
      - media_uploads:/opt/tinyboards/media
      - backend_logs:/opt/tinyboards/logs
      - backup_data:/opt/tinyboards/backups
    command: [
      "sh", "-c",
      "chown -R 1000:1000 /opt/tinyboards/media /opt/tinyboards/logs /opt/tinyboards/backups && chmod -R 755 /opt/tinyboards/media /opt/tinyboards/logs /opt/tinyboards/backups"
    ]
    restart: "no"
    depends_on:
      env-validator:
        condition: service_completed_successfully

  # Nginx reverse proxy with SSL support
  nginx:
    image: nginx:1.25.2-alpine
    container_name: tinyboards_nginx_prod
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf/:/etc/nginx/conf.d:ro
      - ./ssl/:/etc/ssl/certs/:ro
      - nginx_cache:/var/cache/nginx
      - nginx_logs:/var/log/nginx
      - certbot_conf:/etc/letsencrypt:ro
      - certbot_www:/var/www/certbot:ro
    networks:
      - frontend
      - backend
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "10"
        labels: "service,environment=production"
        compress: "true"
    depends_on:
      tinyboards-fe:
        condition: service_healthy
      volume-permissions:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - SETGID
      - SETUID
      - NET_BIND_SERVICE
    environment:
      - NGINX_WORKER_PROCESSES=auto
      - NGINX_WORKER_CONNECTIONS=1024
    # Resource limits for nginx
    deploy:
      resources:
        limits:
          memory: 128M
          cpus: '0.5'
        reservations:
          memory: 64M
          cpus: '0.25'
      update_config:
        parallelism: 1
        failure_action: rollback
        delay: 10s
      rollback_config:
        parallelism: 1
        delay: 10s

  # TinyBoards Backend Service (no exposed ports for security)
  tinyboards:
    image: ${TINYBOARDS_IMAGE:-kronusdev/tinyboards-be:latest}
    container_name: tinyboards_backend_prod
    # Removed port exposure for security - access via nginx only
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "10"
        labels: "service,environment=production"
        compress: "true"
    environment:
      - RUST_LOG=${RUST_LOG:-info,tinyboards_api=info,tinyboards_db=warn}
      - TB_CONFIG_LOCATION=/config/defaults.hjson
      - RUST_BACKTRACE=${RUST_BACKTRACE:-1}
      - DATABASE_URL=postgresql://${POSTGRES_USER:-tinyboards}:${POSTGRES_PASSWORD}@${POSTGRES_HOST:-postgres}:${POSTGRES_PORT:-5432}/${POSTGRES_DB:-tinyboards}
      - JWT_SECRET=${JWT_SECRET}
      - REDIS_URL=redis://:${REDIS_PASSWORD}@${REDIS_HOST:-redis}:${REDIS_PORT:-6379}/${REDIS_DB:-0}
      # Performance tuning
      - TOKIO_WORKER_THREADS=${TOKIO_WORKER_THREADS:-4}
      - TOKIO_BLOCKING_THREADS=${TOKIO_BLOCKING_THREADS:-4}
      # Security
      - RUST_SECURE_ZERO_MEMORY=${RUST_SECURE_ZERO_MEMORY:-1}
    volumes:
      - ./tinyboards.hjson:/config/defaults.hjson:ro
      - media_uploads:/opt/tinyboards/media
      - backend_logs:/opt/tinyboards/logs
    networks:
      - backend
      - database
    user: "1000:1000"
    depends_on:
      volume-permissions:
        condition: service_completed_successfully
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:8536/api/v2/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 45s
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    tmpfs:
      - /tmp:noexec,nosuid,size=100m
    # Enhanced resource management
    deploy:
      resources:
        limits:
          memory: ${BACKEND_MEMORY_LIMIT:-2G}
          cpus: '${BACKEND_CPU_LIMIT:-2.0}'
        reservations:
          memory: 1G
          cpus: '1.0'
      update_config:
        parallelism: 1
        failure_action: rollback
        delay: 30s
        monitor: 60s
      rollback_config:
        parallelism: 1
        delay: 10s
        monitor: 60s

  # TinyBoards Frontend Service (no exposed ports for security)
  tinyboards-fe:
    image: ${TINYBOARDS_FE_IMAGE:-kronusdev/tinyboards-fe:latest}
    container_name: tinyboards_frontend_prod
    # Removed port exposure for security - access via nginx only
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "10"
        labels: "service,environment=production"
        compress: "true"
    environment:
      - NODE_ENV=${NODE_ENV:-production}
      - NUXT_HOST=0.0.0.0
      - NUXT_PORT=3000
      - NITRO_PORT=3000
      - NITRO_HOST=0.0.0.0
      - NUXT_PUBLIC_API_BASE=${NUXT_PUBLIC_API_BASE:-http://tinyboards:8536}
      - NUXT_PUBLIC_DOMAIN=${NUXT_PUBLIC_DOMAIN:-localhost}
      - NUXT_PUBLIC_USE_HTTPS=${NUXT_PUBLIC_USE_HTTPS:-false}
      # Performance optimizations
      - NODE_OPTIONS=${NODE_OPTIONS:---max-old-space-size=1024}
      - UV_THREADPOOL_SIZE=${UV_THREADPOOL_SIZE:-4}
    volumes:
      - frontend_logs:/app/logs
    networks:
      - frontend
      - backend
    depends_on:
      tinyboards:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/health || wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    tmpfs:
      - /tmp:noexec,nosuid,size=50m
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
      update_config:
        parallelism: 1
        failure_action: rollback
        delay: 30s
        monitor: 60s
      rollback_config:
        parallelism: 1
        delay: 10s

  # PostgreSQL Database (internal access only)
  postgres:
    image: postgres:15.4-alpine
    container_name: tinyboards_postgres_prod
    # Removed port exposure for security - internal access only
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "10"
        labels: "service,environment=production"
        compress: "true"
    environment:
      - POSTGRES_USER=${POSTGRES_USER:-tinyboards}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB:-tinyboards}
      - POSTGRES_INITDB_ARGS=--encoding=UTF8 --lc-collate=C --lc-ctype=C
      - PGDATA=/var/lib/postgresql/data/pgdata
      # Security settings
      - POSTGRES_HOST_AUTH_METHOD=scram-sha-256
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - database
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-tinyboards} -d ${POSTGRES_DB:-tinyboards}"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - DAC_OVERRIDE
      - CHOWN
      - SETGID
      - SETUID
    tmpfs:
      - /tmp:noexec,nosuid,size=200m
      - /var/run/postgresql:noexec,nosuid,size=100m
    # Enhanced resource management for production
    deploy:
      resources:
        limits:
          memory: 4G
          cpus: '3.0'
        reservations:
          memory: 2G
          cpus: '1.5'
      update_config:
        parallelism: 1
        failure_action: rollback
        delay: 60s
        monitor: 120s
      rollback_config:
        parallelism: 1
        delay: 30s
    # Production-optimized PostgreSQL configuration
    command: [
      "postgres",
      # Connection and authentication
      "-c", "max_connections=100",
      "-c", "superuser_reserved_connections=3",

      # Memory settings optimized for 4GB container
      "-c", "shared_buffers=1GB",
      "-c", "effective_cache_size=3GB",
      "-c", "work_mem=16MB",
      "-c", "maintenance_work_mem=256MB",
      "-c", "autovacuum_work_mem=128MB",

      # WAL and checkpoint settings
      "-c", "wal_buffers=32MB",
      "-c", "checkpoint_completion_target=0.9",
      "-c", "min_wal_size=2GB",
      "-c", "max_wal_size=8GB",
      "-c", "checkpoint_timeout=15min",
      "-c", "checkpoint_flush_after=256kB",

      # Query planner settings
      "-c", "default_statistics_target=100",
      "-c", "random_page_cost=1.1",
      "-c", "effective_io_concurrency=200",
      "-c", "seq_page_cost=1.0",

      # Parallel query settings
      "-c", "max_worker_processes=4",
      "-c", "max_parallel_workers_per_gather=2",
      "-c", "max_parallel_workers=4",
      "-c", "max_parallel_maintenance_workers=2",

      # Logging (minimal for production)
      "-c", "log_min_duration_statement=5000",
      "-c", "log_line_prefix=%t [%p]: [%l-1] user=%u,db=%d ",
      "-c", "log_checkpoints=on",
      "-c", "log_lock_waits=on",
      "-c", "log_temp_files=10MB",
      "-c", "log_autovacuum_min_duration=1000",

      # Security and performance
      "-c", "ssl=off",
      "-c", "tcp_keepalives_idle=600",
      "-c", "tcp_keepalives_interval=30",
      "-c", "tcp_keepalives_count=3",

      # Autovacuum tuning
      "-c", "autovacuum_max_workers=3",
      "-c", "autovacuum_naptime=15s",
      "-c", "autovacuum_vacuum_threshold=50",
      "-c", "autovacuum_analyze_threshold=50",
      "-c", "autovacuum_vacuum_scale_factor=0.1",
      "-c", "autovacuum_analyze_scale_factor=0.05"
    ]

  # Redis for caching and sessions (secured with authentication)
  redis:
    image: redis:7.2.0-alpine
    container_name: tinyboards_redis_prod
    # Removed port exposure for security - internal access only
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "100m"
        max-file: "10"
        labels: "service,environment=production"
        compress: "true"
    volumes:
      - redis_data:/data
    networks:
      - backend
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "redis-cli -a $$REDIS_PASSWORD ping || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 30s
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - SETGID
      - SETUID
    tmpfs:
      - /tmp:noexec,nosuid,size=50m
    user: "999:999"
    # Resource limits for Redis
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
      update_config:
        parallelism: 1
        failure_action: rollback
        delay: 30s
      rollback_config:
        parallelism: 1
        delay: 10s
    command: [
      "sh", "-c",
      "redis-server --requirepass $$REDIS_PASSWORD --appendonly no --no-appendfsync-on-rewrite yes --auto-aof-rewrite-percentage 0 --save 3600 1 --save 300 100 --save 60 10000 --maxmemory 384mb --maxmemory-policy allkeys-lru --maxmemory-samples 10 --protected-mode yes --tcp-keepalive 300 --loglevel notice --timeout 300 --tcp-backlog 511 --databases 4 --stop-writes-on-bgsave-error yes --dir /data"
    ]

  # SSL Certificate Management with Let's Encrypt
  certbot:
    image: certbot/certbot:latest
    container_name: tinyboards_certbot_prod
    volumes:
      - certbot_conf:/etc/letsencrypt
      - certbot_www:/var/www/certbot
    environment:
      - DOMAIN=${DOMAIN}
      - LETSENCRYPT_EMAIL=${LETSENCRYPT_EMAIL}
    command: |
      sh -c '
      if [ ! -f /etc/letsencrypt/live/$$DOMAIN/fullchain.pem ]; then
        certbot certonly --webroot --webroot-path=/var/www/certbot \
          --email $$LETSENCRYPT_EMAIL --agree-tos --no-eff-email \
          -d $$DOMAIN
      fi
      # Renewal check
      while true; do
        sleep 12h
        certbot renew
      done
      '
    restart: unless-stopped
    depends_on:
      - nginx

  # Database Backup Service
  backup:
    image: postgres:15.4-alpine
    container_name: tinyboards_backup_prod
    volumes:
      - backup_data:/backups
    networks:
      - database
    environment:
      - POSTGRES_USER=${POSTGRES_USER:-tinyboards}
      - POSTGRES_DB=${POSTGRES_DB:-tinyboards}
      - PGPASSWORD=${POSTGRES_PASSWORD}
    command:
      - sh
      - -c
      - |
        while true; do
          echo "Starting backup at $$(date)"
          pg_dump -h postgres -U $$POSTGRES_USER $$POSTGRES_DB | gzip > /backups/backup_$$(date +%Y%m%d_%H%M%S).sql.gz
          find /backups -name "*.sql.gz" -mtime +30 -delete
          echo "Backup completed at $$(date)"
          sleep 86400
        done
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.25'
        reservations:
          memory: 128M
          cpus: '0.1'

  # Monitoring and alerting (optional)
  # prometheus:
  #   image: prom/prometheus:latest
  #   container_name: tinyboards_prometheus_prod
  #   ports:
  #     - "127.0.0.1:9090:9090"
  #   volumes:
  #     - ./prometheus:/etc/prometheus:ro
  #     - prometheus_data:/prometheus
  #   networks:
  #     - tinyboards
  #   <<: *prod-restart
  #   <<: *common-security

networks:
  # Frontend network for nginx and frontend service
  frontend:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/24

  # Backend network for application services
  backend:
    driver: bridge
    internal: false
    ipam:
      config:
        - subnet: 172.21.0.0/24

  # Database network (internal only)
  database:
    driver: bridge
    internal: true
    ipam:
      config:
        - subnet: 172.22.0.0/24

volumes:
  # Application data
  postgres_data:
    name: tinyboards_postgres_prod
    driver: local
  redis_data:
    name: tinyboards_redis_prod
    driver: local
  media_uploads:
    name: tinyboards_media_prod
    driver: local

  # Logs
  nginx_logs:
    name: tinyboards_nginx_logs_prod
    driver: local
  backend_logs:
    name: tinyboards_backend_logs_prod
    driver: local
  frontend_logs:
    name: tinyboards_frontend_logs_prod
    driver: local

  # Caches
  nginx_cache:
    name: tinyboards_nginx_cache_prod
    driver: local

  # SSL certificates
  certbot_conf:
    name: tinyboards_certbot_conf_prod
    driver: local
  certbot_www:
    name: tinyboards_certbot_www_prod
    driver: local

  # Backups
  backup_data:
    name: tinyboards_backup_prod
    driver: local

  # Monitoring (if enabled)
  # prometheus_data:
  #   name: tinyboards_prometheus_prod
  #   driver: local